// Copyright Vespa.ai. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
// macros for up to 9 test fixtures, generated by vespalib/testkit/make_fixture_macros

// common test macro implementation for 0 test fixtures BEGIN

#define TEST_IMPL(name, ignore, threads) \
namespace { \
struct TEST_CAT(TestKitHook, __LINE__) : vespalib::TestHook { \
    TEST_CAT(TestKitHook, __LINE__)() : vespalib::TestHook(__FILE__, name, ignore) {} \
    struct Test : vespalib::TestFixtureWrapper { \
        void test_entry_point() override; \
    }; \
    bool run() override { \
        TEST_STATE(name); \
        Test test; \
        return runTest(test, threads); \
    } \
}; \
TEST_CAT(TestKitHook, __LINE__) TEST_CAT(testKitHook, __LINE__); \
} /* end of unnamed namespace */ \
void TEST_CAT(TestKitHook, __LINE__)::Test::test_entry_point()

// common test macro implementation for 0 test fixtures END

// test macro variants for 0 test fixtures BEGIN

#define TEST(name) TEST_IMPL(name, false, 1) // NOLINT
#define TEST_MT(name, threads) TEST_IMPL(name, false, threads) // NOLINT
#define IGNORE_TEST(name) TEST_IMPL(name, true, 1) // NOLINT
#define IGNORE_TEST_MT(name, threads) TEST_IMPL(name, true, threads) // NOLINT

// test macro variants for 0 test fixtures END

// common test macro implementation for 1 test fixtures BEGIN

#define TEST_F_IMPL(name, ignore, threads, fixture1) \
namespace { \
struct TEST_CAT(TestKitHook, __LINE__) : vespalib::TestHook { \
    TEST_CAT(TestKitHook, __LINE__)() : vespalib::TestHook(__FILE__, name, ignore) {} \
    template <typename F1> \
    struct Test : vespalib::TestFixtureWrapper { \
        F1 &f; \
        F1 &f1; \
        Test(F1 &f1_in) : f(f1_in), f1(f1_in) {} \
        void test_entry_point() override; \
    }; \
    template <typename F1> \
    bool dispatch1(F1 *_f1_ptr_) { \
        std::unique_ptr<F1> _f1_ap_(_f1_ptr_); \
        F1 &f1 = *_f1_ap_; \
        Test<F1> test(f1); \
        return runTest(test, threads); \
    } \
    bool run() override { \
        TEST_STATE(name); \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch1(new fixture1); \
    } \
}; \
TEST_CAT(TestKitHook, __LINE__) TEST_CAT(testKitHook, __LINE__); \
} /* end of unnamed namespace */ \
template <typename F1> \
void TEST_CAT(TestKitHook, __LINE__)::Test<F1>::test_entry_point()

// common test macro implementation for 1 test fixtures END

// test macro variants for 1 test fixtures BEGIN

#define TEST_F(name, fixture1) TEST_F_IMPL(name, false, 1, fixture1) // NOLINT
#define TEST_MT_F(name, threads, fixture1) TEST_F_IMPL(name, false, threads, fixture1) // NOLINT
#define IGNORE_TEST_F(name, fixture1) TEST_F_IMPL(name, true, 1, fixture1) // NOLINT
#define IGNORE_TEST_MT_F(name, threads, fixture1) TEST_F_IMPL(name, true, threads, fixture1) // NOLINT

// test macro variants for 1 test fixtures END

// common test macro implementation for 2 test fixtures BEGIN

#define TEST_FF_IMPL(name, ignore, threads, fixture1, fixture2) \
namespace { \
struct TEST_CAT(TestKitHook, __LINE__) : vespalib::TestHook { \
    TEST_CAT(TestKitHook, __LINE__)() : vespalib::TestHook(__FILE__, name, ignore) {} \
    template <typename F1, typename F2> \
    struct Test : vespalib::TestFixtureWrapper { \
        F1 &f1; \
        F2 &f2; \
        Test(F1 &f1_in, F2 &f2_in) : f1(f1_in), f2(f2_in) {} \
        void test_entry_point() override; \
    }; \
    template <typename F1, typename F2> \
    bool dispatch2(F1 &f1, F2 *_f2_ptr_) { \
        std::unique_ptr<F2> _f2_ap_(_f2_ptr_); \
        F2 &f2 = *_f2_ap_; \
        Test<F1, F2> test(f1, f2); \
        return runTest(test, threads); \
    } \
    template <typename F1> \
    bool dispatch1(F1 *_f1_ptr_) { \
        std::unique_ptr<F1> _f1_ap_(_f1_ptr_); \
        F1 &f1 = *_f1_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch2(f1, new fixture2); \
    } \
    bool run() override { \
        TEST_STATE(name); \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch1(new fixture1); \
    } \
}; \
TEST_CAT(TestKitHook, __LINE__) TEST_CAT(testKitHook, __LINE__); \
} /* end of unnamed namespace */ \
template <typename F1, typename F2> \
void TEST_CAT(TestKitHook, __LINE__)::Test<F1, F2>::test_entry_point()

// common test macro implementation for 2 test fixtures END

// test macro variants for 2 test fixtures BEGIN

#define TEST_FF(name, fixture1, fixture2) TEST_FF_IMPL(name, false, 1, fixture1, fixture2) // NOLINT
#define TEST_MT_FF(name, threads, fixture1, fixture2) TEST_FF_IMPL(name, false, threads, fixture1, fixture2) // NOLINT
#define IGNORE_TEST_FF(name, fixture1, fixture2) TEST_FF_IMPL(name, true, 1, fixture1, fixture2) // NOLINT
#define IGNORE_TEST_MT_FF(name, threads, fixture1, fixture2) TEST_FF_IMPL(name, true, threads, fixture1, fixture2) // NOLINT

// test macro variants for 2 test fixtures END

// common test macro implementation for 3 test fixtures BEGIN

#define TEST_FFF_IMPL(name, ignore, threads, fixture1, fixture2, fixture3) \
namespace { \
struct TEST_CAT(TestKitHook, __LINE__) : vespalib::TestHook { \
    TEST_CAT(TestKitHook, __LINE__)() : vespalib::TestHook(__FILE__, name, ignore) {} \
    template <typename F1, typename F2, typename F3> \
    struct Test : vespalib::TestFixtureWrapper { \
        F1 &f1; \
        F2 &f2; \
        F3 &f3; \
        Test(F1 &f1_in, F2 &f2_in, F3 &f3_in) : f1(f1_in), f2(f2_in), f3(f3_in) {} \
        void test_entry_point() override; \
    }; \
    template <typename F1, typename F2, typename F3> \
    bool dispatch3(F1 &f1, F2 &f2, F3 *_f3_ptr_) { \
        std::unique_ptr<F3> _f3_ap_(_f3_ptr_); \
        F3 &f3 = *_f3_ap_; \
        Test<F1, F2, F3> test(f1, f2, f3); \
        return runTest(test, threads); \
    } \
    template <typename F1, typename F2> \
    bool dispatch2(F1 &f1, F2 *_f2_ptr_) { \
        std::unique_ptr<F2> _f2_ap_(_f2_ptr_); \
        F2 &f2 = *_f2_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch3(f1, f2, new fixture3); \
    } \
    template <typename F1> \
    bool dispatch1(F1 *_f1_ptr_) { \
        std::unique_ptr<F1> _f1_ap_(_f1_ptr_); \
        F1 &f1 = *_f1_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch2(f1, new fixture2); \
    } \
    bool run() override { \
        TEST_STATE(name); \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch1(new fixture1); \
    } \
}; \
TEST_CAT(TestKitHook, __LINE__) TEST_CAT(testKitHook, __LINE__); \
} /* end of unnamed namespace */ \
template <typename F1, typename F2, typename F3> \
void TEST_CAT(TestKitHook, __LINE__)::Test<F1, F2, F3>::test_entry_point()

// common test macro implementation for 3 test fixtures END

// test macro variants for 3 test fixtures BEGIN

#define TEST_FFF(name, fixture1, fixture2, fixture3) TEST_FFF_IMPL(name, false, 1, fixture1, fixture2, fixture3) // NOLINT
#define TEST_MT_FFF(name, threads, fixture1, fixture2, fixture3) TEST_FFF_IMPL(name, false, threads, fixture1, fixture2, fixture3) // NOLINT
#define IGNORE_TEST_FFF(name, fixture1, fixture2, fixture3) TEST_FFF_IMPL(name, true, 1, fixture1, fixture2, fixture3) // NOLINT
#define IGNORE_TEST_MT_FFF(name, threads, fixture1, fixture2, fixture3) TEST_FFF_IMPL(name, true, threads, fixture1, fixture2, fixture3) // NOLINT

// test macro variants for 3 test fixtures END

// common test macro implementation for 4 test fixtures BEGIN

#define TEST_FFFF_IMPL(name, ignore, threads, fixture1, fixture2, fixture3, fixture4) \
namespace { \
struct TEST_CAT(TestKitHook, __LINE__) : vespalib::TestHook { \
    TEST_CAT(TestKitHook, __LINE__)() : vespalib::TestHook(__FILE__, name, ignore) {} \
    template <typename F1, typename F2, typename F3, typename F4> \
    struct Test : vespalib::TestFixtureWrapper { \
        F1 &f1; \
        F2 &f2; \
        F3 &f3; \
        F4 &f4; \
        Test(F1 &f1_in, F2 &f2_in, F3 &f3_in, F4 &f4_in) : f1(f1_in), f2(f2_in), f3(f3_in), f4(f4_in) {} \
        void test_entry_point() override; \
    }; \
    template <typename F1, typename F2, typename F3, typename F4> \
    bool dispatch4(F1 &f1, F2 &f2, F3 &f3, F4 *_f4_ptr_) { \
        std::unique_ptr<F4> _f4_ap_(_f4_ptr_); \
        F4 &f4 = *_f4_ap_; \
        Test<F1, F2, F3, F4> test(f1, f2, f3, f4); \
        return runTest(test, threads); \
    } \
    template <typename F1, typename F2, typename F3> \
    bool dispatch3(F1 &f1, F2 &f2, F3 *_f3_ptr_) { \
        std::unique_ptr<F3> _f3_ap_(_f3_ptr_); \
        F3 &f3 = *_f3_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch4(f1, f2, f3, new fixture4); \
    } \
    template <typename F1, typename F2> \
    bool dispatch2(F1 &f1, F2 *_f2_ptr_) { \
        std::unique_ptr<F2> _f2_ap_(_f2_ptr_); \
        F2 &f2 = *_f2_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch3(f1, f2, new fixture3); \
    } \
    template <typename F1> \
    bool dispatch1(F1 *_f1_ptr_) { \
        std::unique_ptr<F1> _f1_ap_(_f1_ptr_); \
        F1 &f1 = *_f1_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch2(f1, new fixture2); \
    } \
    bool run() override { \
        TEST_STATE(name); \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch1(new fixture1); \
    } \
}; \
TEST_CAT(TestKitHook, __LINE__) TEST_CAT(testKitHook, __LINE__); \
} /* end of unnamed namespace */ \
template <typename F1, typename F2, typename F3, typename F4> \
void TEST_CAT(TestKitHook, __LINE__)::Test<F1, F2, F3, F4>::test_entry_point()

// common test macro implementation for 4 test fixtures END

// test macro variants for 4 test fixtures BEGIN

#define TEST_FFFF(name, fixture1, fixture2, fixture3, fixture4) TEST_FFFF_IMPL(name, false, 1, fixture1, fixture2, fixture3, fixture4) // NOLINT
#define TEST_MT_FFFF(name, threads, fixture1, fixture2, fixture3, fixture4) TEST_FFFF_IMPL(name, false, threads, fixture1, fixture2, fixture3, fixture4) // NOLINT
#define IGNORE_TEST_FFFF(name, fixture1, fixture2, fixture3, fixture4) TEST_FFFF_IMPL(name, true, 1, fixture1, fixture2, fixture3, fixture4) // NOLINT
#define IGNORE_TEST_MT_FFFF(name, threads, fixture1, fixture2, fixture3, fixture4) TEST_FFFF_IMPL(name, true, threads, fixture1, fixture2, fixture3, fixture4) // NOLINT

// test macro variants for 4 test fixtures END

// common test macro implementation for 5 test fixtures BEGIN

#define TEST_FFFFF_IMPL(name, ignore, threads, fixture1, fixture2, fixture3, fixture4, fixture5) \
namespace { \
struct TEST_CAT(TestKitHook, __LINE__) : vespalib::TestHook { \
    TEST_CAT(TestKitHook, __LINE__)() : vespalib::TestHook(__FILE__, name, ignore) {} \
    template <typename F1, typename F2, typename F3, typename F4, typename F5> \
    struct Test : vespalib::TestFixtureWrapper { \
        F1 &f1; \
        F2 &f2; \
        F3 &f3; \
        F4 &f4; \
        F5 &f5; \
        Test(F1 &f1_in, F2 &f2_in, F3 &f3_in, F4 &f4_in, F5 &f5_in) : f1(f1_in), f2(f2_in), f3(f3_in), f4(f4_in), f5(f5_in) {} \
        void test_entry_point() override; \
    }; \
    template <typename F1, typename F2, typename F3, typename F4, typename F5> \
    bool dispatch5(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 *_f5_ptr_) { \
        std::unique_ptr<F5> _f5_ap_(_f5_ptr_); \
        F5 &f5 = *_f5_ap_; \
        Test<F1, F2, F3, F4, F5> test(f1, f2, f3, f4, f5); \
        return runTest(test, threads); \
    } \
    template <typename F1, typename F2, typename F3, typename F4> \
    bool dispatch4(F1 &f1, F2 &f2, F3 &f3, F4 *_f4_ptr_) { \
        std::unique_ptr<F4> _f4_ap_(_f4_ptr_); \
        F4 &f4 = *_f4_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch5(f1, f2, f3, f4, new fixture5); \
    } \
    template <typename F1, typename F2, typename F3> \
    bool dispatch3(F1 &f1, F2 &f2, F3 *_f3_ptr_) { \
        std::unique_ptr<F3> _f3_ap_(_f3_ptr_); \
        F3 &f3 = *_f3_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch4(f1, f2, f3, new fixture4); \
    } \
    template <typename F1, typename F2> \
    bool dispatch2(F1 &f1, F2 *_f2_ptr_) { \
        std::unique_ptr<F2> _f2_ap_(_f2_ptr_); \
        F2 &f2 = *_f2_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch3(f1, f2, new fixture3); \
    } \
    template <typename F1> \
    bool dispatch1(F1 *_f1_ptr_) { \
        std::unique_ptr<F1> _f1_ap_(_f1_ptr_); \
        F1 &f1 = *_f1_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch2(f1, new fixture2); \
    } \
    bool run() override { \
        TEST_STATE(name); \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch1(new fixture1); \
    } \
}; \
TEST_CAT(TestKitHook, __LINE__) TEST_CAT(testKitHook, __LINE__); \
} /* end of unnamed namespace */ \
template <typename F1, typename F2, typename F3, typename F4, typename F5> \
void TEST_CAT(TestKitHook, __LINE__)::Test<F1, F2, F3, F4, F5>::test_entry_point()

// common test macro implementation for 5 test fixtures END

// test macro variants for 5 test fixtures BEGIN

#define TEST_FFFFF(name, fixture1, fixture2, fixture3, fixture4, fixture5) TEST_FFFFF_IMPL(name, false, 1, fixture1, fixture2, fixture3, fixture4, fixture5) // NOLINT
#define TEST_MT_FFFFF(name, threads, fixture1, fixture2, fixture3, fixture4, fixture5) TEST_FFFFF_IMPL(name, false, threads, fixture1, fixture2, fixture3, fixture4, fixture5) // NOLINT
#define IGNORE_TEST_FFFFF(name, fixture1, fixture2, fixture3, fixture4, fixture5) TEST_FFFFF_IMPL(name, true, 1, fixture1, fixture2, fixture3, fixture4, fixture5) // NOLINT
#define IGNORE_TEST_MT_FFFFF(name, threads, fixture1, fixture2, fixture3, fixture4, fixture5) TEST_FFFFF_IMPL(name, true, threads, fixture1, fixture2, fixture3, fixture4, fixture5) // NOLINT

// test macro variants for 5 test fixtures END

// common test macro implementation for 6 test fixtures BEGIN

#define TEST_FFFFFF_IMPL(name, ignore, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6) \
namespace { \
struct TEST_CAT(TestKitHook, __LINE__) : vespalib::TestHook { \
    TEST_CAT(TestKitHook, __LINE__)() : vespalib::TestHook(__FILE__, name, ignore) {} \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6> \
    struct Test : vespalib::TestFixtureWrapper { \
        F1 &f1; \
        F2 &f2; \
        F3 &f3; \
        F4 &f4; \
        F5 &f5; \
        F6 &f6; \
        Test(F1 &f1_in, F2 &f2_in, F3 &f3_in, F4 &f4_in, F5 &f5_in, F6 &f6_in) : f1(f1_in), f2(f2_in), f3(f3_in), f4(f4_in), f5(f5_in), f6(f6_in) {} \
        void test_entry_point() override; \
    }; \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6> \
    bool dispatch6(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 &f5, F6 *_f6_ptr_) { \
        std::unique_ptr<F6> _f6_ap_(_f6_ptr_); \
        F6 &f6 = *_f6_ap_; \
        Test<F1, F2, F3, F4, F5, F6> test(f1, f2, f3, f4, f5, f6); \
        return runTest(test, threads); \
    } \
    template <typename F1, typename F2, typename F3, typename F4, typename F5> \
    bool dispatch5(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 *_f5_ptr_) { \
        std::unique_ptr<F5> _f5_ap_(_f5_ptr_); \
        F5 &f5 = *_f5_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch6(f1, f2, f3, f4, f5, new fixture6); \
    } \
    template <typename F1, typename F2, typename F3, typename F4> \
    bool dispatch4(F1 &f1, F2 &f2, F3 &f3, F4 *_f4_ptr_) { \
        std::unique_ptr<F4> _f4_ap_(_f4_ptr_); \
        F4 &f4 = *_f4_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch5(f1, f2, f3, f4, new fixture5); \
    } \
    template <typename F1, typename F2, typename F3> \
    bool dispatch3(F1 &f1, F2 &f2, F3 *_f3_ptr_) { \
        std::unique_ptr<F3> _f3_ap_(_f3_ptr_); \
        F3 &f3 = *_f3_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch4(f1, f2, f3, new fixture4); \
    } \
    template <typename F1, typename F2> \
    bool dispatch2(F1 &f1, F2 *_f2_ptr_) { \
        std::unique_ptr<F2> _f2_ap_(_f2_ptr_); \
        F2 &f2 = *_f2_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch3(f1, f2, new fixture3); \
    } \
    template <typename F1> \
    bool dispatch1(F1 *_f1_ptr_) { \
        std::unique_ptr<F1> _f1_ap_(_f1_ptr_); \
        F1 &f1 = *_f1_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch2(f1, new fixture2); \
    } \
    bool run() override { \
        TEST_STATE(name); \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch1(new fixture1); \
    } \
}; \
TEST_CAT(TestKitHook, __LINE__) TEST_CAT(testKitHook, __LINE__); \
} /* end of unnamed namespace */ \
template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6> \
void TEST_CAT(TestKitHook, __LINE__)::Test<F1, F2, F3, F4, F5, F6>::test_entry_point()

// common test macro implementation for 6 test fixtures END

// test macro variants for 6 test fixtures BEGIN

#define TEST_FFFFFF(name, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6) TEST_FFFFFF_IMPL(name, false, 1, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6) // NOLINT
#define TEST_MT_FFFFFF(name, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6) TEST_FFFFFF_IMPL(name, false, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6) // NOLINT
#define IGNORE_TEST_FFFFFF(name, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6) TEST_FFFFFF_IMPL(name, true, 1, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6) // NOLINT
#define IGNORE_TEST_MT_FFFFFF(name, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6) TEST_FFFFFF_IMPL(name, true, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6) // NOLINT

// test macro variants for 6 test fixtures END

// common test macro implementation for 7 test fixtures BEGIN

#define TEST_FFFFFFF_IMPL(name, ignore, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7) \
namespace { \
struct TEST_CAT(TestKitHook, __LINE__) : vespalib::TestHook { \
    TEST_CAT(TestKitHook, __LINE__)() : vespalib::TestHook(__FILE__, name, ignore) {} \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7> \
    struct Test : vespalib::TestFixtureWrapper { \
        F1 &f1; \
        F2 &f2; \
        F3 &f3; \
        F4 &f4; \
        F5 &f5; \
        F6 &f6; \
        F7 &f7; \
        Test(F1 &f1_in, F2 &f2_in, F3 &f3_in, F4 &f4_in, F5 &f5_in, F6 &f6_in, F7 &f7_in) : f1(f1_in), f2(f2_in), f3(f3_in), f4(f4_in), f5(f5_in), f6(f6_in), f7(f7_in) {} \
        void test_entry_point() override; \
    }; \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7> \
    bool dispatch7(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 &f5, F6 &f6, F7 *_f7_ptr_) { \
        std::unique_ptr<F7> _f7_ap_(_f7_ptr_); \
        F7 &f7 = *_f7_ap_; \
        Test<F1, F2, F3, F4, F5, F6, F7> test(f1, f2, f3, f4, f5, f6, f7); \
        return runTest(test, threads); \
    } \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6> \
    bool dispatch6(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 &f5, F6 *_f6_ptr_) { \
        std::unique_ptr<F6> _f6_ap_(_f6_ptr_); \
        F6 &f6 = *_f6_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch7(f1, f2, f3, f4, f5, f6, new fixture7); \
    } \
    template <typename F1, typename F2, typename F3, typename F4, typename F5> \
    bool dispatch5(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 *_f5_ptr_) { \
        std::unique_ptr<F5> _f5_ap_(_f5_ptr_); \
        F5 &f5 = *_f5_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch6(f1, f2, f3, f4, f5, new fixture6); \
    } \
    template <typename F1, typename F2, typename F3, typename F4> \
    bool dispatch4(F1 &f1, F2 &f2, F3 &f3, F4 *_f4_ptr_) { \
        std::unique_ptr<F4> _f4_ap_(_f4_ptr_); \
        F4 &f4 = *_f4_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch5(f1, f2, f3, f4, new fixture5); \
    } \
    template <typename F1, typename F2, typename F3> \
    bool dispatch3(F1 &f1, F2 &f2, F3 *_f3_ptr_) { \
        std::unique_ptr<F3> _f3_ap_(_f3_ptr_); \
        F3 &f3 = *_f3_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch4(f1, f2, f3, new fixture4); \
    } \
    template <typename F1, typename F2> \
    bool dispatch2(F1 &f1, F2 *_f2_ptr_) { \
        std::unique_ptr<F2> _f2_ap_(_f2_ptr_); \
        F2 &f2 = *_f2_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch3(f1, f2, new fixture3); \
    } \
    template <typename F1> \
    bool dispatch1(F1 *_f1_ptr_) { \
        std::unique_ptr<F1> _f1_ap_(_f1_ptr_); \
        F1 &f1 = *_f1_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch2(f1, new fixture2); \
    } \
    bool run() override { \
        TEST_STATE(name); \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch1(new fixture1); \
    } \
}; \
TEST_CAT(TestKitHook, __LINE__) TEST_CAT(testKitHook, __LINE__); \
} /* end of unnamed namespace */ \
template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7> \
void TEST_CAT(TestKitHook, __LINE__)::Test<F1, F2, F3, F4, F5, F6, F7>::test_entry_point()

// common test macro implementation for 7 test fixtures END

// test macro variants for 7 test fixtures BEGIN

#define TEST_FFFFFFF(name, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7) TEST_FFFFFFF_IMPL(name, false, 1, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7) // NOLINT
#define TEST_MT_FFFFFFF(name, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7) TEST_FFFFFFF_IMPL(name, false, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7) // NOLINT
#define IGNORE_TEST_FFFFFFF(name, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7) TEST_FFFFFFF_IMPL(name, true, 1, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7) // NOLINT
#define IGNORE_TEST_MT_FFFFFFF(name, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7) TEST_FFFFFFF_IMPL(name, true, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7) // NOLINT

// test macro variants for 7 test fixtures END

// common test macro implementation for 8 test fixtures BEGIN

#define TEST_FFFFFFFF_IMPL(name, ignore, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8) \
namespace { \
struct TEST_CAT(TestKitHook, __LINE__) : vespalib::TestHook { \
    TEST_CAT(TestKitHook, __LINE__)() : vespalib::TestHook(__FILE__, name, ignore) {} \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8> \
    struct Test : vespalib::TestFixtureWrapper { \
        F1 &f1; \
        F2 &f2; \
        F3 &f3; \
        F4 &f4; \
        F5 &f5; \
        F6 &f6; \
        F7 &f7; \
        F8 &f8; \
        Test(F1 &f1_in, F2 &f2_in, F3 &f3_in, F4 &f4_in, F5 &f5_in, F6 &f6_in, F7 &f7_in, F8 &f8_in) : f1(f1_in), f2(f2_in), f3(f3_in), f4(f4_in), f5(f5_in), f6(f6_in), f7(f7_in), f8(f8_in) {} \
        void test_entry_point() override; \
    }; \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8> \
    bool dispatch8(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 &f5, F6 &f6, F7 &f7, F8 *_f8_ptr_) { \
        std::unique_ptr<F8> _f8_ap_(_f8_ptr_); \
        F8 &f8 = *_f8_ap_; \
        Test<F1, F2, F3, F4, F5, F6, F7, F8> test(f1, f2, f3, f4, f5, f6, f7, f8); \
        return runTest(test, threads); \
    } \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7> \
    bool dispatch7(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 &f5, F6 &f6, F7 *_f7_ptr_) { \
        std::unique_ptr<F7> _f7_ap_(_f7_ptr_); \
        F7 &f7 = *_f7_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch8(f1, f2, f3, f4, f5, f6, f7, new fixture8); \
    } \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6> \
    bool dispatch6(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 &f5, F6 *_f6_ptr_) { \
        std::unique_ptr<F6> _f6_ap_(_f6_ptr_); \
        F6 &f6 = *_f6_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch7(f1, f2, f3, f4, f5, f6, new fixture7); \
    } \
    template <typename F1, typename F2, typename F3, typename F4, typename F5> \
    bool dispatch5(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 *_f5_ptr_) { \
        std::unique_ptr<F5> _f5_ap_(_f5_ptr_); \
        F5 &f5 = *_f5_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch6(f1, f2, f3, f4, f5, new fixture6); \
    } \
    template <typename F1, typename F2, typename F3, typename F4> \
    bool dispatch4(F1 &f1, F2 &f2, F3 &f3, F4 *_f4_ptr_) { \
        std::unique_ptr<F4> _f4_ap_(_f4_ptr_); \
        F4 &f4 = *_f4_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch5(f1, f2, f3, f4, new fixture5); \
    } \
    template <typename F1, typename F2, typename F3> \
    bool dispatch3(F1 &f1, F2 &f2, F3 *_f3_ptr_) { \
        std::unique_ptr<F3> _f3_ap_(_f3_ptr_); \
        F3 &f3 = *_f3_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch4(f1, f2, f3, new fixture4); \
    } \
    template <typename F1, typename F2> \
    bool dispatch2(F1 &f1, F2 *_f2_ptr_) { \
        std::unique_ptr<F2> _f2_ap_(_f2_ptr_); \
        F2 &f2 = *_f2_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch3(f1, f2, new fixture3); \
    } \
    template <typename F1> \
    bool dispatch1(F1 *_f1_ptr_) { \
        std::unique_ptr<F1> _f1_ap_(_f1_ptr_); \
        F1 &f1 = *_f1_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch2(f1, new fixture2); \
    } \
    bool run() override { \
        TEST_STATE(name); \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch1(new fixture1); \
    } \
}; \
TEST_CAT(TestKitHook, __LINE__) TEST_CAT(testKitHook, __LINE__); \
} /* end of unnamed namespace */ \
template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8> \
void TEST_CAT(TestKitHook, __LINE__)::Test<F1, F2, F3, F4, F5, F6, F7, F8>::test_entry_point()

// common test macro implementation for 8 test fixtures END

// test macro variants for 8 test fixtures BEGIN

#define TEST_FFFFFFFF(name, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8) TEST_FFFFFFFF_IMPL(name, false, 1, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8) // NOLINT
#define TEST_MT_FFFFFFFF(name, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8) TEST_FFFFFFFF_IMPL(name, false, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8) // NOLINT
#define IGNORE_TEST_FFFFFFFF(name, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8) TEST_FFFFFFFF_IMPL(name, true, 1, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8) // NOLINT
#define IGNORE_TEST_MT_FFFFFFFF(name, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8) TEST_FFFFFFFF_IMPL(name, true, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8) // NOLINT

// test macro variants for 8 test fixtures END

// common test macro implementation for 9 test fixtures BEGIN

#define TEST_FFFFFFFFF_IMPL(name, ignore, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8, fixture9) \
namespace { \
struct TEST_CAT(TestKitHook, __LINE__) : vespalib::TestHook { \
    TEST_CAT(TestKitHook, __LINE__)() : vespalib::TestHook(__FILE__, name, ignore) {} \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9> \
    struct Test : vespalib::TestFixtureWrapper { \
        F1 &f1; \
        F2 &f2; \
        F3 &f3; \
        F4 &f4; \
        F5 &f5; \
        F6 &f6; \
        F7 &f7; \
        F8 &f8; \
        F9 &f9; \
        Test(F1 &f1_in, F2 &f2_in, F3 &f3_in, F4 &f4_in, F5 &f5_in, F6 &f6_in, F7 &f7_in, F8 &f8_in, F9 &f9_in) : f1(f1_in), f2(f2_in), f3(f3_in), f4(f4_in), f5(f5_in), f6(f6_in), f7(f7_in), f8(f8_in), f9(f9_in) {} \
        void test_entry_point() override; \
    }; \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9> \
    bool dispatch9(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 &f5, F6 &f6, F7 &f7, F8 &f8, F9 *_f9_ptr_) { \
        std::unique_ptr<F9> _f9_ap_(_f9_ptr_); \
        F9 &f9 = *_f9_ap_; \
        Test<F1, F2, F3, F4, F5, F6, F7, F8, F9> test(f1, f2, f3, f4, f5, f6, f7, f8, f9); \
        return runTest(test, threads); \
    } \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8> \
    bool dispatch8(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 &f5, F6 &f6, F7 &f7, F8 *_f8_ptr_) { \
        std::unique_ptr<F8> _f8_ap_(_f8_ptr_); \
        F8 &f8 = *_f8_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch9(f1, f2, f3, f4, f5, f6, f7, f8, new fixture9); \
    } \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7> \
    bool dispatch7(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 &f5, F6 &f6, F7 *_f7_ptr_) { \
        std::unique_ptr<F7> _f7_ap_(_f7_ptr_); \
        F7 &f7 = *_f7_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch8(f1, f2, f3, f4, f5, f6, f7, new fixture8); \
    } \
    template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6> \
    bool dispatch6(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 &f5, F6 *_f6_ptr_) { \
        std::unique_ptr<F6> _f6_ap_(_f6_ptr_); \
        F6 &f6 = *_f6_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch7(f1, f2, f3, f4, f5, f6, new fixture7); \
    } \
    template <typename F1, typename F2, typename F3, typename F4, typename F5> \
    bool dispatch5(F1 &f1, F2 &f2, F3 &f3, F4 &f4, F5 *_f5_ptr_) { \
        std::unique_ptr<F5> _f5_ap_(_f5_ptr_); \
        F5 &f5 = *_f5_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch6(f1, f2, f3, f4, f5, new fixture6); \
    } \
    template <typename F1, typename F2, typename F3, typename F4> \
    bool dispatch4(F1 &f1, F2 &f2, F3 &f3, F4 *_f4_ptr_) { \
        std::unique_ptr<F4> _f4_ap_(_f4_ptr_); \
        F4 &f4 = *_f4_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch5(f1, f2, f3, f4, new fixture5); \
    } \
    template <typename F1, typename F2, typename F3> \
    bool dispatch3(F1 &f1, F2 &f2, F3 *_f3_ptr_) { \
        std::unique_ptr<F3> _f3_ap_(_f3_ptr_); \
        F3 &f3 = *_f3_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch4(f1, f2, f3, new fixture4); \
    } \
    template <typename F1, typename F2> \
    bool dispatch2(F1 &f1, F2 *_f2_ptr_) { \
        std::unique_ptr<F2> _f2_ap_(_f2_ptr_); \
        F2 &f2 = *_f2_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch3(f1, f2, new fixture3); \
    } \
    template <typename F1> \
    bool dispatch1(F1 *_f1_ptr_) { \
        std::unique_ptr<F1> _f1_ap_(_f1_ptr_); \
        F1 &f1 = *_f1_ap_; \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch2(f1, new fixture2); \
    } \
    bool run() override { \
        TEST_STATE(name); \
        size_t num_threads(threads); (void) num_threads; \
        return dispatch1(new fixture1); \
    } \
}; \
TEST_CAT(TestKitHook, __LINE__) TEST_CAT(testKitHook, __LINE__); \
} /* end of unnamed namespace */ \
template <typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9> \
void TEST_CAT(TestKitHook, __LINE__)::Test<F1, F2, F3, F4, F5, F6, F7, F8, F9>::test_entry_point()

// common test macro implementation for 9 test fixtures END

// test macro variants for 9 test fixtures BEGIN

#define TEST_FFFFFFFFF(name, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8, fixture9) TEST_FFFFFFFFF_IMPL(name, false, 1, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8, fixture9) // NOLINT
#define TEST_MT_FFFFFFFFF(name, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8, fixture9) TEST_FFFFFFFFF_IMPL(name, false, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8, fixture9) // NOLINT
#define IGNORE_TEST_FFFFFFFFF(name, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8, fixture9) TEST_FFFFFFFFF_IMPL(name, true, 1, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8, fixture9) // NOLINT
#define IGNORE_TEST_MT_FFFFFFFFF(name, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8, fixture9) TEST_FFFFFFFFF_IMPL(name, true, threads, fixture1, fixture2, fixture3, fixture4, fixture5, fixture6, fixture7, fixture8, fixture9) // NOLINT

// test macro variants for 9 test fixtures END

