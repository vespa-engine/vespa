// Copyright Vespa.ai. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.

#pragma once

#include "detached_rpc_request.h"
#include <vespa/fnet/task.h>
#include <vespa/searchcore/proton/flushengine/flush_strategy_id_listener.h>
#include <chrono>
#include <memory>

namespace proton {

/*
 * Set flush strategy rpc request to proton rpc interface that has been detached. This is an abstract class,
 * rpc result is generated by functions implemented in a child class.
 */
class SetFlushStrategyRpcHandler : public DetachedRpcRequest,
                                   public flushengine::FlushStrategyIdListener,
                                   public FNET_Task,
                                   public std::enable_shared_from_this<SetFlushStrategyRpcHandler> {
protected:
    uint32_t                _ticks;
    uint32_t                _wait_strategy_id;
    uint32_t                _strategy_id;
    std::atomic<uint8_t>    _completed;
    std::chrono::steady_clock::time_point _start_time;
    std::chrono::steady_clock::duration   _timeout;
    struct Completed {
        static constexpr uint8_t started = 0;
        static constexpr uint8_t owner_aborted = 1;
        static constexpr uint8_t notifier_closed = 2;
        static constexpr uint8_t done = 3;
        static constexpr uint8_t timeout = 4;
        static constexpr uint8_t lost_conn = 5;
        static constexpr uint8_t missing_wait_strategy_id = 6;
    };
    bool set_complete(uint8_t value) noexcept;
    uint8_t get_complete() const noexcept { return _completed.load(std::memory_order_acquire); }
    bool is_success() const noexcept { return get_complete() == Completed::done; }
public:
    SetFlushStrategyRpcHandler(std::shared_ptr<DetachedRpcRequestsOwner> owner,
                               vespalib::ref_counted<FRT_RPCRequest> req,
                               std::shared_ptr<flushengine::FlushStrategyIdNotifier> notifier,
                               FNET_Scheduler* scheduler,
                               uint32_t wait_strategy_id,
                               std::chrono::steady_clock::duration timeout);
    ~SetFlushStrategyRpcHandler() override;
    void setup();
    std::future<void> owner_aborted() override;
    void set_strategy_id(uint32_t strategy_id) override;
    void notifier_closed() override;
    void PerformTask() override;
    virtual void make_result() = 0;
};

}
